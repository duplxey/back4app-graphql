# Exposes a URL that specifies the behaviour of this scalar.
directive @specifiedBy(
  # The URL that specifies the behaviour of this scalar.
  url: String!
) on SCALAR

# Current access control list of the current object.
type ACL {
  # Access control list for users.
  users: [UserACL!]

  # Access control list for roles.
  roles: [RoleACL!]

  # Public access control list.
  public: PublicACL
}

# Allow to manage access rights. If not provided object will be publicly readable and writable
input ACLInput {
  # Access control list for users.
  users: [UserACLInput!]

  # Access control list for roles.
  roles: [RoleACLInput!]

  # Public access control list.
  public: PublicACLInput
}

# The Any scalar type is used in operations and types that involve any type of value.
scalar Any

# Use Inline Fragment on Array to get results: https://graphql.org/learn/queries/#inline-fragments
union ArrayResult =
  Element
  | Role
  | User
  | Author
  | Book
  | Category
  | Task
  | TaskCategory

# The ArrayWhereInput input type is used in operations that involve filtering objects by a field of type Array.
input ArrayWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Any

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Any

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Any

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Any

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Any

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Any

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Any]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Any]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the containedBy operator to specify a constraint to select the objects
  # where the values of an array field is contained by another specified array.
  containedBy: [Any]

  # This is the contains operator to specify a constraint to select the objects
  # where the values of an array field contain all elements of another specified array.
  contains: [Any]

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The Author object type is used in operations that involve outputting objects of Author class.
type Author implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object firstName.
  firstName: String!

  # This is the object lastName.
  lastName: String!

  # This is the object dateOfBirth.
  dateOfBirth: Date
}

# A connection to a list of items.
type AuthorConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [AuthorEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type AuthorEdge {
  # The item at the end of the edge
  node: Author

  # A cursor for use in pagination
  cursor: String!
}

# The AuthorOrder input type is used when sorting objects of the Author class.
enum AuthorOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Author class.
input AuthorPointerInput {
  # Link an existing object from Author class. You can use either the global or the object id.
  link: ID

  # Create and link an object from Author class.
  createAndLink: CreateAuthorFieldsInput
}

# Allow to add, remove, createAndAdd objects of the Author class into a relation field.
input AuthorRelationInput {
  # Add existing objects from the Author class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the Author class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the Author class into the relation.
  createAndAdd: [CreateAuthorFieldsInput!]
}

# The AuthorRelationWhereInput input type is used in operations that involve filtering objects of Author class.
input AuthorRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: AuthorWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: AuthorWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The AuthorWhereInput input type is used in operations that involve filtering objects of Author class.
input AuthorWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object firstName.
  firstName: StringWhereInput

  # This is the object lastName.
  lastName: StringWhereInput

  # This is the object dateOfBirth.
  dateOfBirth: DateWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [AuthorWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [AuthorWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [AuthorWhereInput!]
}

# The Book object type is used in operations that involve outputting objects of Book class.
type Book implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object name.
  name: String!

  # This is the object description.
  description: String!

  # This is the object publishDate.
  publishDate: String!

  # This is the object author.
  author: Author!

  # This is the object categories.
  categories(
    # These are the conditions that the objects need to match in order to be found.
    where: CategoryWhereInput

    # The fields to be used when sorting the data fetched.
    order: [CategoryOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): CategoryConnection!
}

# A connection to a list of items.
type BookConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BookEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type BookEdge {
  # The item at the end of the edge
  node: Book

  # A cursor for use in pagination
  cursor: String!
}

# The BookOrder input type is used when sorting objects of the Book class.
enum BookOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  publishDate_ASC
  publishDate_DESC
  author_ASC
  author_DESC
  categories_ASC
  categories_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Book class.
input BookPointerInput {
  # Link an existing object from Book class. You can use either the global or the object id.
  link: ID

  # Create and link an object from Book class.
  createAndLink: CreateBookFieldsInput
}

# Allow to add, remove, createAndAdd objects of the Book class into a relation field.
input BookRelationInput {
  # Add existing objects from the Book class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the Book class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the Book class into the relation.
  createAndAdd: [CreateBookFieldsInput!]
}

# The BookRelationWhereInput input type is used in operations that involve filtering objects of Book class.
input BookRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: BookWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: BookWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The BookWhereInput input type is used in operations that involve filtering objects of Book class.
input BookWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object name.
  name: StringWhereInput

  # This is the object description.
  description: StringWhereInput

  # This is the object publishDate.
  publishDate: StringWhereInput

  # This is the object author.
  author: AuthorRelationWhereInput

  # This is the object categories.
  categories: CategoryRelationWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [BookWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [BookWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [BookWhereInput!]
}

# The BooleanWhereInput input type is used in operations that involve filtering objects by a field of type Boolean.
input BooleanWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Boolean

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Boolean

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The BoxInput type is used to specifiy a box operation on a within geo query.
input BoxInput {
  # This is the bottom left coordinates of the box.
  bottomLeft: GeoPointInput!

  # This is the upper right coordinates of the box.
  upperRight: GeoPointInput!
}

# The Bytes scalar type is used in operations and types that involve base 64 binary data.
scalar Bytes

# The BytesWhereInput input type is used in operations that involve filtering objects by a field of type Bytes.
input BytesWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Bytes

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Bytes

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Bytes

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Bytes

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Bytes

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Bytes

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Bytes]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Bytes]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The Category object type is used in operations that involve outputting objects of Category class.
type Category implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object name.
  name: String!

  # This is the object description.
  description: String
}

# A connection to a list of items.
type CategoryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [CategoryEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type CategoryEdge {
  # The item at the end of the edge
  node: Category

  # A cursor for use in pagination
  cursor: String!
}

# The CategoryOrder input type is used when sorting objects of the Category class.
enum CategoryOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Category class.
input CategoryPointerInput {
  # Link an existing object from Category class. You can use either the global or the object id.
  link: ID

  # Create and link an object from Category class.
  createAndLink: CreateCategoryFieldsInput
}

# Allow to add, remove, createAndAdd objects of the Category class into a relation field.
input CategoryRelationInput {
  # Add existing objects from the Category class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the Category class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the Category class into the relation.
  createAndAdd: [CreateCategoryFieldsInput!]
}

# The CategoryRelationWhereInput input type is used in operations that involve filtering objects of Category class.
input CategoryRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: CategoryWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: CategoryWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The CategoryWhereInput input type is used in operations that involve filtering objects of Category class.
input CategoryWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object name.
  name: StringWhereInput

  # This is the object description.
  description: StringWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [CategoryWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [CategoryWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [CategoryWhereInput!]
}

# The CenterSphereInput type is used to specifiy a centerSphere operation on a geoWithin query.
input CenterSphereInput {
  # This is the center of the sphere.
  center: GeoPointInput!

  # This is the radius of the sphere.
  distance: Float!
}

# The Class type is used to return the information about an object class.
type Class {
  # This is the name of the object class.
  name: String!

  # These are the schema's fields of the object class.
  schemaFields: [SchemaField!]!
}

# The CreateAuthorFieldsInput input type is used in operations that involve creation of objects in the Author class.
input CreateAuthorFieldsInput {
  ACL: ACLInput

  # This is the object firstName.
  firstName: String!

  # This is the object lastName.
  lastName: String!

  # This is the object dateOfBirth.
  dateOfBirth: Date
}

input CreateAuthorInput {
  # These are the fields that will be used to create the new object.
  fields: CreateAuthorFieldsInput
  clientMutationId: String
}

type CreateAuthorPayload {
  # This is the created object.
  author: Author!
  clientMutationId: String
}

# The CreateBookFieldsInput input type is used in operations that involve creation of objects in the Book class.
input CreateBookFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String!

  # This is the object description.
  description: String!

  # This is the object publishDate.
  publishDate: String!

  # This is the object author.
  author: AuthorPointerInput!

  # This is the object categories.
  categories: CategoryRelationInput
}

input CreateBookInput {
  # These are the fields that will be used to create the new object.
  fields: CreateBookFieldsInput
  clientMutationId: String
}

type CreateBookPayload {
  # This is the created object.
  book: Book!
  clientMutationId: String
}

# The CreateCategoryFieldsInput input type is used in operations that involve creation of objects in the Category class.
input CreateCategoryFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String!

  # This is the object description.
  description: String
}

input CreateCategoryInput {
  # These are the fields that will be used to create the new object.
  fields: CreateCategoryFieldsInput
  clientMutationId: String
}

type CreateCategoryPayload {
  # This is the created object.
  category: Category!
  clientMutationId: String
}

input CreateClassInput {
  # This is the name of the object class.
  name: String!

  # These are the schema's fields of the object class.
  schemaFields: SchemaFieldsInput
  clientMutationId: String
}

type CreateClassPayload {
  # This is the created class.
  class: Class!
  clientMutationId: String
}

input CreateFileInput {
  # This is the new file to be created and uploaded.
  upload: Upload!
  clientMutationId: String
}

type CreateFilePayload {
  # This is the created file info.
  fileInfo: FileInfo!
  clientMutationId: String
}

# The CreateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class.
input CreateRoleFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object users.
  users: UserRelationInput

  # This is the object roles.
  roles: RoleRelationInput
}

input CreateRoleInput {
  # These are the fields that will be used to create the new object.
  fields: CreateRoleFieldsInput
  clientMutationId: String
}

type CreateRolePayload {
  # This is the created object.
  role: Role!
  clientMutationId: String
}

# The CreateTaskCategoryFieldsInput input type is used in operations that involve
# creation of objects in the TaskCategory class.
input CreateTaskCategoryFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String!

  # This is the object description.
  description: String
}

input CreateTaskCategoryInput {
  # These are the fields that will be used to create the new object.
  fields: CreateTaskCategoryFieldsInput
  clientMutationId: String
}

type CreateTaskCategoryPayload {
  # This is the created object.
  taskCategory: TaskCategory!
  clientMutationId: String
}

# The CreateTaskFieldsInput input type is used in operations that involve creation of objects in the Task class.
input CreateTaskFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String!

  # This is the object description.
  description: String

  # This is the object isDone.
  isDone: Boolean!

  # This is the object categories.
  categories: TaskCategoryRelationInput
}

input CreateTaskInput {
  # These are the fields that will be used to create the new object.
  fields: CreateTaskFieldsInput
  clientMutationId: String
}

type CreateTaskPayload {
  # This is the created object.
  task: Task!
  clientMutationId: String
}

# The CreateUserFieldsInput input type is used in operations that involve creation of objects in the User class.
input CreateUserFieldsInput {
  ACL: ACLInput

  # This is the object username.
  username: String!

  # This is the object password.
  password: String!

  # This is the object email.
  email: String

  # This is the object emailVerified.
  emailVerified: Boolean

  # This is the object authData.
  authData: Object
}

input CreateUserInput {
  # These are the fields that will be used to create the new object.
  fields: CreateUserFieldsInput
  clientMutationId: String
}

type CreateUserPayload {
  # This is the created object.
  user: User!
  clientMutationId: String
}

# The Date scalar type is used in operations and types that involve dates.
scalar Date

# The DateWhereInput input type is used in operations that involve filtering objects by a field of type Date.
input DateWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Date

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Date

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Date

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Date

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Date

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Date

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Date]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Date]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

input DeleteAuthorInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteAuthorPayload {
  # This is the deleted object.
  author: Author!
  clientMutationId: String
}

input DeleteBookInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteBookPayload {
  # This is the deleted object.
  book: Book!
  clientMutationId: String
}

input DeleteCategoryInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteCategoryPayload {
  # This is the deleted object.
  category: Category!
  clientMutationId: String
}

input DeleteClassInput {
  # This is the name of the object class.
  name: String!
  clientMutationId: String
}

type DeleteClassPayload {
  # This is the deleted class.
  class: Class!
  clientMutationId: String
}

input DeleteRoleInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteRolePayload {
  # This is the deleted object.
  role: Role!
  clientMutationId: String
}

input DeleteTaskCategoryInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteTaskCategoryPayload {
  # This is the deleted object.
  taskCategory: TaskCategory!
  clientMutationId: String
}

input DeleteTaskInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteTaskPayload {
  # This is the deleted object.
  task: Task!
  clientMutationId: String
}

input DeleteUserInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!
  clientMutationId: String
}

type DeleteUserPayload {
  # This is the deleted object.
  user: User!
  clientMutationId: String
}

# The Element object type is used to return array items' value.
type Element {
  # Return the value of the element in the array
  value: Any!
}

# The File scalar type is used in operations and types that involve files.
scalar File

# The FileInfo object type is used to return the information about files.
type FileInfo {
  # This is the file name.
  name: String!

  # This is the url in which the file can be downloaded.
  url: String!
}

input FileInput {
  # A File Scalar can be an url or a FileInfo object. If this field is set to null the file will be unlinked.
  file: File

  # Use this field if you want to create a new file.
  upload: Upload

  # Use this field if you want to unlink the file (the file will not be deleted on cloud storage)
  unlink: Boolean
}

# The FileWhereInput input type is used in operations that involve filtering objects by a field of type File.
input FileWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: File

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: File

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: File

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: File

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: File

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: File

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [File]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [File]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the matchesRegex operator to specify a constraint to select the
  # objects where the value of a field matches a specified regular expression.
  matchesRegex: String

  # This is the options operator to specify optional flags (such as "i" and "m")
  # to be added to a matchesRegex operation in the same set of constraints.
  options: String

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The GeoIntersectsInput type is used to specify a geoIntersects operation on a constraint.
input GeoIntersectsInput {
  # This is the point to be specified.
  point: GeoPointInput
}

# The GeoPoint object type is used to return the information about geo point fields.
type GeoPoint {
  # This is the latitude.
  latitude: Float!

  # This is the longitude.
  longitude: Float!
}

# The GeoPointInput type is used in operations that involve inputting fields of type geo point.
input GeoPointInput {
  # This is the latitude.
  latitude: Float!

  # This is the longitude.
  longitude: Float!
}

# The GeoPointWhereInput input type is used in operations that involve filtering objects by a field of type GeoPoint.
input GeoPointWhereInput {
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the nearSphere operator to specify a constraint to select the objects
  # where the values of a geo point field is near to another geo point.
  nearSphere: GeoPointInput

  # This is the maxDistance operator to specify a constraint to select the objects
  # where the values of a geo point field is at a max distance (in radians) from
  # the geo point specified in the $nearSphere operator.
  maxDistance: Float

  # This is the maxDistanceInRadians operator to specify a constraint to select
  # the objects where the values of a geo point field is at a max distance (in
  # radians) from the geo point specified in the $nearSphere operator.
  maxDistanceInRadians: Float

  # This is the maxDistanceInMiles operator to specify a constraint to select the
  # objects where the values of a geo point field is at a max distance (in miles)
  # from the geo point specified in the $nearSphere operator.
  maxDistanceInMiles: Float

  # This is the maxDistanceInKilometers operator to specify a constraint to select
  # the objects where the values of a geo point field is at a max distance (in
  # kilometers) from the geo point specified in the $nearSphere operator.
  maxDistanceInKilometers: Float

  # This is the within operator to specify a constraint to select the objects
  # where the values of a geo point field is within a specified box.
  within: WithinInput

  # This is the geoWithin operator to specify a constraint to select the objects
  # where the values of a geo point field is within a specified polygon or sphere.
  geoWithin: GeoWithinInput
}

# The GeoWithinInput type is used to specify a geoWithin operation on a constraint.
input GeoWithinInput {
  # This is the polygon to be specified.
  polygon: [GeoPointInput!]

  # This is the sphere to be specified.
  centerSphere: CenterSphereInput
}

# The IdWhereInput input type is used in operations that involve filtering objects by an id.
input IdWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: ID

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: ID

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: ID

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: ID

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# An entry from an object, i.e., a pair of key and value.
input KeyValueInput {
  # The key used to retrieve the value of this entry.
  key: String!

  # The value of the entry. Could be any type of scalar data.
  value: Any!
}

input LogInInput {
  # This is the username used to log in the user.
  username: String!

  # This is the password used to log in the user.
  password: String!
  clientMutationId: String
}

type LogInPayload {
  # This is the existing user that was logged in and returned as a viewer.
  viewer: Viewer!
  clientMutationId: String
}

input LogInWithInput {
  authData: Object!
  fields: UserLoginWithInput
  clientMutationId: String
}

type LogInWithPayload {
  # This is the new user that was created, signed up and returned as a viewer.
  viewer: Viewer!
  clientMutationId: String
}

input LogOutInput {
  clientMutationId: String
}

type LogOutPayload {
  # It's always true.
  ok: Boolean!
  clientMutationId: String
}

# Mutation is the top level type for mutations.
type Mutation {
  # The createRole mutation can be used to create a new object of the Role class.
  createRole(input: CreateRoleInput!): CreateRolePayload

  # The updateRole mutation can be used to update an object of the Role class.
  updateRole(input: UpdateRoleInput!): UpdateRolePayload

  # The deleteRole mutation can be used to delete an object of the Role class.
  deleteRole(input: DeleteRoleInput!): DeleteRolePayload

  # The createUser mutation can be used to create a new object of the User class.
  createUser(input: CreateUserInput!): CreateUserPayload

  # The updateUser mutation can be used to update an object of the User class.
  updateUser(input: UpdateUserInput!): UpdateUserPayload

  # The deleteUser mutation can be used to delete an object of the User class.
  deleteUser(input: DeleteUserInput!): DeleteUserPayload

  # The createAuthor mutation can be used to create a new object of the Author class.
  createAuthor(input: CreateAuthorInput!): CreateAuthorPayload

  # The updateAuthor mutation can be used to update an object of the Author class.
  updateAuthor(input: UpdateAuthorInput!): UpdateAuthorPayload

  # The deleteAuthor mutation can be used to delete an object of the Author class.
  deleteAuthor(input: DeleteAuthorInput!): DeleteAuthorPayload

  # The createBook mutation can be used to create a new object of the Book class.
  createBook(input: CreateBookInput!): CreateBookPayload

  # The updateBook mutation can be used to update an object of the Book class.
  updateBook(input: UpdateBookInput!): UpdateBookPayload

  # The deleteBook mutation can be used to delete an object of the Book class.
  deleteBook(input: DeleteBookInput!): DeleteBookPayload

  # The createCategory mutation can be used to create a new object of the Category class.
  createCategory(input: CreateCategoryInput!): CreateCategoryPayload

  # The updateCategory mutation can be used to update an object of the Category class.
  updateCategory(input: UpdateCategoryInput!): UpdateCategoryPayload

  # The deleteCategory mutation can be used to delete an object of the Category class.
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryPayload

  # The createTask mutation can be used to create a new object of the Task class.
  createTask(input: CreateTaskInput!): CreateTaskPayload

  # The updateTask mutation can be used to update an object of the Task class.
  updateTask(input: UpdateTaskInput!): UpdateTaskPayload

  # The deleteTask mutation can be used to delete an object of the Task class.
  deleteTask(input: DeleteTaskInput!): DeleteTaskPayload

  # The createTaskCategory mutation can be used to create a new object of the TaskCategory class.
  createTaskCategory(input: CreateTaskCategoryInput!): CreateTaskCategoryPayload

  # The updateTaskCategory mutation can be used to update an object of the TaskCategory class.
  updateTaskCategory(input: UpdateTaskCategoryInput!): UpdateTaskCategoryPayload

  # The deleteTaskCategory mutation can be used to delete an object of the TaskCategory class.
  deleteTaskCategory(input: DeleteTaskCategoryInput!): DeleteTaskCategoryPayload

  # The createFile mutation can be used to create and upload a new file.
  createFile(input: CreateFileInput!): CreateFilePayload

  # The signUp mutation can be used to create and sign up a new user.
  signUp(input: SignUpInput!): SignUpPayload

  # The logInWith mutation can be used to signup, login user with 3rd party
  # authentication system. This mutation create a user if the authData do not
  # correspond to an existing one.
  logInWith(input: LogInWithInput!): LogInWithPayload

  # The logIn mutation can be used to log in an existing user.
  logIn(input: LogInInput!): LogInPayload

  # The logOut mutation can be used to log out an existing user.
  logOut(input: LogOutInput!): LogOutPayload

  # The resetPassword mutation can be used to reset the password of an existing user.
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload

  # The sendVerificationEmail mutation can be used to send the verification email again.
  sendVerificationEmail(
    input: SendVerificationEmailInput!
  ): SendVerificationEmailPayload

  # The createClass mutation can be used to create the schema for a new object class.
  createClass(input: CreateClassInput!): CreateClassPayload

  # The updateClass mutation can be used to update the schema for an existing object class.
  updateClass(input: UpdateClassInput!): UpdateClassPayload

  # The deleteClass mutation can be used to delete an existing object class.
  deleteClass(input: DeleteClassInput!): DeleteClassPayload
}

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

# The NumberWhereInput input type is used in operations that involve filtering objects by a field of type Number.
input NumberWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Float

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Float

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Float

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Float

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Float

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Float

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Float]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Float]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The Object scalar type is used in operations and types that involve objects.
scalar Object

# The ObjectWhereInput input type is used in operations that involve filtering result by a field of type Object.
input ObjectWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: KeyValueInput

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: KeyValueInput

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [KeyValueInput]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [KeyValueInput]

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: KeyValueInput

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: KeyValueInput

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: KeyValueInput

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: KeyValueInput

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

# The ParseObject interface type is used as a base type for the auto generated object types.
interface ParseObject {
  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!
}

# The PointerFieldInput is used to specify a field of type pointer for an object class schema.
input PointerFieldInput {
  # This is the field name.
  name: String!

  # This is the name of the target class for the field.
  targetClassName: String!
}

# The PolygonWhereInput input type is used in operations that involve filtering objects by a field of type Polygon.
input PolygonWhereInput {
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the geoIntersects operator to specify a constraint to select the
  # objects where the values of a polygon field intersect a specified point.
  geoIntersects: GeoIntersectsInput
}

# Allow to manage public rights.
type PublicACL {
  # Allow anyone to read the current object.
  read: Boolean

  # Allow anyone to write on the current object.
  write: Boolean
}

# Allow to manage public rights.
input PublicACLInput {
  # Allow anyone to read the current object.
  read: Boolean!

  # Allow anyone to write on the current object.
  write: Boolean!
}

# Query is the top level type for queries.
type Query {
  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node

  # The role query can be used to get an object of the Role class by its id.
  role(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Role!

  # The roles query can be used to find objects of the Role class.
  roles(
    # These are the conditions that the objects need to match in order to be found.
    where: RoleWhereInput

    # The fields to be used when sorting the data fetched.
    order: [RoleOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): RoleConnection!

  # The user query can be used to get an object of the User class by its id.
  user(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): User!

  # The users query can be used to find objects of the User class.
  users(
    # These are the conditions that the objects need to match in order to be found.
    where: UserWhereInput

    # The fields to be used when sorting the data fetched.
    order: [UserOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): UserConnection!

  # The author query can be used to get an object of the Author class by its id.
  author(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Author!

  # The authors query can be used to find objects of the Author class.
  authors(
    # These are the conditions that the objects need to match in order to be found.
    where: AuthorWhereInput

    # The fields to be used when sorting the data fetched.
    order: [AuthorOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): AuthorConnection!

  # The book query can be used to get an object of the Book class by its id.
  book(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Book!

  # The books query can be used to find objects of the Book class.
  books(
    # These are the conditions that the objects need to match in order to be found.
    where: BookWhereInput

    # The fields to be used when sorting the data fetched.
    order: [BookOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): BookConnection!

  # The category query can be used to get an object of the Category class by its id.
  category(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Category!

  # The categories query can be used to find objects of the Category class.
  categories(
    # These are the conditions that the objects need to match in order to be found.
    where: CategoryWhereInput

    # The fields to be used when sorting the data fetched.
    order: [CategoryOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): CategoryConnection!

  # The task query can be used to get an object of the Task class by its id.
  task(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Task!

  # The tasks query can be used to find objects of the Task class.
  tasks(
    # These are the conditions that the objects need to match in order to be found.
    where: TaskWhereInput

    # The fields to be used when sorting the data fetched.
    order: [TaskOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TaskConnection!

  # The taskCategory query can be used to get an object of the TaskCategory class by its id.
  taskCategory(
    # This is the object id. You can use either the global or the object id.
    id: ID!

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TaskCategory!

  # The taskCategories query can be used to find objects of the TaskCategory class.
  taskCategories(
    # These are the conditions that the objects need to match in order to be found.
    where: TaskCategoryWhereInput

    # The fields to be used when sorting the data fetched.
    order: [TaskCategoryOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TaskCategoryConnection!

  # The health query can be used to check if the server is up and running.
  health: Boolean!

  # The viewer query can be used to return the current user data.
  viewer: Viewer!

  # The class query can be used to retrieve an existing object class.
  class(
    # This is the name of the object class.
    name: String!
  ): Class!

  # The classes query can be used to retrieve the existing object classes.
  classes: [Class!]!
}

# The ReadOptionsInputt type is used in queries in order to set the read preferences.
input ReadOptionsInput {
  # The read preference for the main query to be executed.
  readPreference: ReadPreference

  # The read preference for the queries to be executed to include fields.
  includeReadPreference: ReadPreference

  # The read preference for the subqueries that may be required.
  subqueryReadPreference: ReadPreference
}

# The ReadPreference enum type is used in queries in order to select in which database replica the operation must run.
enum ReadPreference {
  PRIMARY
  PRIMARY_PREFERRED
  SECONDARY
  SECONDARY_PREFERRED
  NEAREST
}

# The RelationFieldInput is used to specify a field of type relation for an object class schema.
input RelationFieldInput {
  # This is the field name.
  name: String!

  # This is the name of the target class for the field.
  targetClassName: String!
}

input ResetPasswordInput {
  email: String!
  clientMutationId: String
}

type ResetPasswordPayload {
  # It's always true.
  ok: Boolean!
  clientMutationId: String
}

# The Role object type is used in operations that involve outputting objects of Role class.
type Role implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object name.
  name: String

  # This is the object users.
  users(
    # These are the conditions that the objects need to match in order to be found.
    where: UserWhereInput

    # The fields to be used when sorting the data fetched.
    order: [UserOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): UserConnection!

  # This is the object roles.
  roles(
    # These are the conditions that the objects need to match in order to be found.
    where: RoleWhereInput

    # The fields to be used when sorting the data fetched.
    order: [RoleOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): RoleConnection!
}

# Allow to manage roles in ACL. If read and write are null the role have read and write rights.
type RoleACL {
  # Name of the targetted Role.
  roleName: ID!

  # Allow users who are members of the role to read the current object.
  read: Boolean!

  # Allow users who are members of the role to write on the current object.
  write: Boolean!
}

# Allow to manage roles in ACL.
input RoleACLInput {
  # Name of the targetted Role.
  roleName: String!

  # Allow users who are members of the role to read the current object.
  read: Boolean!

  # Allow users who are members of the role to write on the current object.
  write: Boolean!
}

# A connection to a list of items.
type RoleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RoleEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type RoleEdge {
  # The item at the end of the edge
  node: Role

  # A cursor for use in pagination
  cursor: String!
}

# The RoleOrder input type is used when sorting objects of the Role class.
enum RoleOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  users_ASC
  users_DESC
  roles_ASC
  roles_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Role class.
input RolePointerInput {
  # Link an existing object from Role class. You can use either the global or the object id.
  link: ID

  # Create and link an object from Role class.
  createAndLink: CreateRoleFieldsInput
}

# Allow to add, remove, createAndAdd objects of the Role class into a relation field.
input RoleRelationInput {
  # Add existing objects from the Role class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the Role class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the Role class into the relation.
  createAndAdd: [CreateRoleFieldsInput!]
}

# The RoleRelationWhereInput input type is used in operations that involve filtering objects of Role class.
input RoleRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: RoleWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: RoleWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The RoleWhereInput input type is used in operations that involve filtering objects of Role class.
input RoleWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object name.
  name: StringWhereInput

  # This is the object users.
  users: UserRelationWhereInput

  # This is the object roles.
  roles: RoleRelationWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [RoleWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [RoleWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [RoleWhereInput!]
}

# The SchemaACLField is used to return information of an ACL field.
type SchemaACLField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaArrayField is used to return information of an Array field.
type SchemaArrayField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaArrayFieldInput is used to specify a field of type array for an object class schema.
input SchemaArrayFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaBooleanField is used to return information of a Boolean field.
type SchemaBooleanField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaBooleanFieldInput is used to specify a field of type boolean for an object class schema.
input SchemaBooleanFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaBytesField is used to return information of a Bytes field.
type SchemaBytesField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaBytesFieldInput is used to specify a field of type bytes for an object class schema.
input SchemaBytesFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaDateField is used to return information of a Date field.
type SchemaDateField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaDateFieldInput is used to specify a field of type date for an object class schema.
input SchemaDateFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaField interface type is used as a base type for the different supported fields of an object class schema.
interface SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaFieldInput is used to specify a field of an object class schema.
input SchemaFieldInput {
  # This is the field name.
  name: String!
}

# The CreateClassSchemaInput type is used to specify the schema for a new object class to be created.
input SchemaFieldsInput {
  # These are the String fields to be added to the class schema.
  addStrings: [SchemaStringFieldInput!]

  # These are the Number fields to be added to the class schema.
  addNumbers: [SchemaNumberFieldInput!]

  # These are the Boolean fields to be added to the class schema.
  addBooleans: [SchemaBooleanFieldInput!]

  # These are the Array fields to be added to the class schema.
  addArrays: [SchemaArrayFieldInput!]

  # These are the Object fields to be added to the class schema.
  addObjects: [SchemaObjectFieldInput!]

  # These are the Date fields to be added to the class schema.
  addDates: [SchemaDateFieldInput!]

  # These are the File fields to be added to the class schema.
  addFiles: [SchemaFileFieldInput!]

  # This is the Geo Point field to be added to the class schema. Currently it is supported only one GeoPoint field per Class.
  addGeoPoint: SchemaGeoPointFieldInput

  # These are the Polygon fields to be added to the class schema.
  addPolygons: [SchemaPolygonFieldInput!]

  # These are the Bytes fields to be added to the class schema.
  addBytes: [SchemaBytesFieldInput!]

  # These are the Pointer fields to be added to the class schema.
  addPointers: [PointerFieldInput!]

  # These are the Relation fields to be added to the class schema.
  addRelations: [RelationFieldInput!]

  # These are the fields to be removed from the class schema.
  remove: [SchemaFieldInput!]
}

# The SchemaFileField is used to return information of a File field.
type SchemaFileField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaFileFieldInput is used to specify a field of type file for an object class schema.
input SchemaFileFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaGeoPointField is used to return information of a Geo Point field.
type SchemaGeoPointField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaGeoPointFieldInput is used to specify a field of type geo point for an object class schema.
input SchemaGeoPointFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaNumberField is used to return information of a Number field.
type SchemaNumberField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaNumberFieldInput is used to specify a field of type number for an object class schema.
input SchemaNumberFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaObjectField is used to return information of an Object field.
type SchemaObjectField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaObjectFieldInput is used to specify a field of type object for an object class schema.
input SchemaObjectFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaPointerField is used to return information of a Pointer field.
type SchemaPointerField implements SchemaField {
  # This is the field name.
  name: String!

  # This is the name of the target class for the field.
  targetClassName: String!
}

# The SchemaPolygonField is used to return information of a Polygon field.
type SchemaPolygonField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaPolygonFieldInput is used to specify a field of type polygon for an object class schema.
input SchemaPolygonFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaRelationField is used to return information of a Relation field.
type SchemaRelationField implements SchemaField {
  # This is the field name.
  name: String!

  # This is the name of the target class for the field.
  targetClassName: String!
}

# The SchemaStringField is used to return information of a String field.
type SchemaStringField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaStringFieldInput is used to specify a field of type string for an object class schema.
input SchemaStringFieldInput {
  # This is the field name.
  name: String!
}

# The SearchInput type is used to specifiy a search operation on a full text search.
input SearchInput {
  # This is the term to be searched.
  term: String!

  # This is the language to tetermine the list of stop words and the rules for tokenizer.
  language: String

  # This is the flag to enable or disable case sensitive search.
  caseSensitive: Boolean

  # This is the flag to enable or disable diacritic sensitive search.
  diacriticSensitive: Boolean
}

# The SelectInput type is used to specify an inQueryKey or a notInQueryKey operation on a constraint.
input SelectInput {
  # This is the subquery to be executed.
  query: SubqueryInput!

  # This is the key in the result of the subquery that must match (not match) the field.
  key: String!
}

input SendVerificationEmailInput {
  email: String!
  clientMutationId: String
}

type SendVerificationEmailPayload {
  # It's always true.
  ok: Boolean!
  clientMutationId: String
}

input SignUpInput {
  fields: CreateUserFieldsInput
  clientMutationId: String
}

type SignUpPayload {
  # This is the new user that was created, signed up and returned as a viewer.
  viewer: Viewer!
  clientMutationId: String
}

# The StringWhereInput input type is used in operations that involve filtering objects by a field of type String.
input StringWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: String

  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: String

  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: String

  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: String

  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: String

  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: String

  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [String]

  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [String]

  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean

  # This is the matchesRegex operator to specify a constraint to select the
  # objects where the value of a field matches a specified regular expression.
  matchesRegex: String

  # This is the options operator to specify optional flags (such as "i" and "m")
  # to be added to a matchesRegex operation in the same set of constraints.
  options: String

  # This is the $text operator to specify a full text search constraint.
  text: TextInput

  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput

  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The SubqueryInput type is used to specify a sub query to another class.
input SubqueryInput {
  # This is the class name of the object.
  className: String!

  # These are the conditions that the objects need to match in order to be found
  where: Object!
}

# The Task object type is used in operations that involve outputting objects of Task class.
type Task implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object name.
  name: String!

  # This is the object description.
  description: String

  # This is the object isDone.
  isDone: Boolean!

  # This is the object categories.
  categories(
    # These are the conditions that the objects need to match in order to be found.
    where: TaskCategoryWhereInput

    # The fields to be used when sorting the data fetched.
    order: [TaskCategoryOrder!]

    # This is the number of objects that must be skipped to return.
    skip: Int
    after: String
    first: Int
    before: String
    last: Int

    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TaskCategoryConnection!
}

# The TaskCategory object type is used in operations that involve outputting objects of TaskCategory class.
type TaskCategory implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object name.
  name: String!

  # This is the object description.
  description: String
}

# A connection to a list of items.
type TaskCategoryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TaskCategoryEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type TaskCategoryEdge {
  # The item at the end of the edge
  node: TaskCategory

  # A cursor for use in pagination
  cursor: String!
}

# The TaskCategoryOrder input type is used when sorting objects of the TaskCategory class.
enum TaskCategoryOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the TaskCategory class.
input TaskCategoryPointerInput {
  # Link an existing object from TaskCategory class. You can use either the global or the object id.
  link: ID

  # Create and link an object from TaskCategory class.
  createAndLink: CreateTaskCategoryFieldsInput
}

# Allow to add, remove, createAndAdd objects of the TaskCategory class into a relation field.
input TaskCategoryRelationInput {
  # Add existing objects from the TaskCategory class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the TaskCategory class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the TaskCategory class into the relation.
  createAndAdd: [CreateTaskCategoryFieldsInput!]
}

# The TaskCategoryRelationWhereInput input type is used in operations that involve filtering objects of TaskCategory class.
input TaskCategoryRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: TaskCategoryWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: TaskCategoryWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The TaskCategoryWhereInput input type is used in operations that involve filtering objects of TaskCategory class.
input TaskCategoryWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object name.
  name: StringWhereInput

  # This is the object description.
  description: StringWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [TaskCategoryWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [TaskCategoryWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [TaskCategoryWhereInput!]
}

# A connection to a list of items.
type TaskConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TaskEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type TaskEdge {
  # The item at the end of the edge
  node: Task

  # A cursor for use in pagination
  cursor: String!
}

# The TaskOrder input type is used when sorting objects of the Task class.
enum TaskOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  isDone_ASC
  isDone_DESC
  categories_ASC
  categories_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Task class.
input TaskPointerInput {
  # Link an existing object from Task class. You can use either the global or the object id.
  link: ID

  # Create and link an object from Task class.
  createAndLink: CreateTaskFieldsInput
}

# Allow to add, remove, createAndAdd objects of the Task class into a relation field.
input TaskRelationInput {
  # Add existing objects from the Task class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the Task class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the Task class into the relation.
  createAndAdd: [CreateTaskFieldsInput!]
}

# The TaskRelationWhereInput input type is used in operations that involve filtering objects of Task class.
input TaskRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: TaskWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: TaskWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The TaskWhereInput input type is used in operations that involve filtering objects of Task class.
input TaskWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object name.
  name: StringWhereInput

  # This is the object description.
  description: StringWhereInput

  # This is the object isDone.
  isDone: BooleanWhereInput

  # This is the object categories.
  categories: TaskCategoryRelationWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [TaskWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [TaskWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [TaskWhereInput!]
}

# The TextInput type is used to specify a text operation on a constraint.
input TextInput {
  # This is the search to be executed.
  search: SearchInput!
}

# The UpdateAuthorFieldsInput input type is used in operations that involve creation of objects in the Author class.
input UpdateAuthorFieldsInput {
  ACL: ACLInput

  # This is the object firstName.
  firstName: String

  # This is the object lastName.
  lastName: String

  # This is the object dateOfBirth.
  dateOfBirth: Date
}

input UpdateAuthorInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateAuthorFieldsInput
  clientMutationId: String
}

type UpdateAuthorPayload {
  # This is the updated object.
  author: Author!
  clientMutationId: String
}

# The UpdateBookFieldsInput input type is used in operations that involve creation of objects in the Book class.
input UpdateBookFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object description.
  description: String

  # This is the object publishDate.
  publishDate: String

  # This is the object author.
  author: AuthorPointerInput

  # This is the object categories.
  categories: CategoryRelationInput
}

input UpdateBookInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateBookFieldsInput
  clientMutationId: String
}

type UpdateBookPayload {
  # This is the updated object.
  book: Book!
  clientMutationId: String
}

# The UpdateCategoryFieldsInput input type is used in operations that involve creation of objects in the Category class.
input UpdateCategoryFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object description.
  description: String
}

input UpdateCategoryInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateCategoryFieldsInput
  clientMutationId: String
}

type UpdateCategoryPayload {
  # This is the updated object.
  category: Category!
  clientMutationId: String
}

input UpdateClassInput {
  # This is the name of the object class.
  name: String!

  # These are the schema's fields of the object class.
  schemaFields: SchemaFieldsInput
  clientMutationId: String
}

type UpdateClassPayload {
  # This is the updated class.
  class: Class!
  clientMutationId: String
}

# The UpdateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class.
input UpdateRoleFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object users.
  users: UserRelationInput

  # This is the object roles.
  roles: RoleRelationInput
}

input UpdateRoleInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateRoleFieldsInput
  clientMutationId: String
}

type UpdateRolePayload {
  # This is the updated object.
  role: Role!
  clientMutationId: String
}

# The UpdateTaskCategoryFieldsInput input type is used in operations that involve
# creation of objects in the TaskCategory class.
input UpdateTaskCategoryFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object description.
  description: String
}

input UpdateTaskCategoryInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateTaskCategoryFieldsInput
  clientMutationId: String
}

type UpdateTaskCategoryPayload {
  # This is the updated object.
  taskCategory: TaskCategory!
  clientMutationId: String
}

# The UpdateTaskFieldsInput input type is used in operations that involve creation of objects in the Task class.
input UpdateTaskFieldsInput {
  ACL: ACLInput

  # This is the object name.
  name: String

  # This is the object description.
  description: String

  # This is the object isDone.
  isDone: Boolean

  # This is the object categories.
  categories: TaskCategoryRelationInput
}

input UpdateTaskInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateTaskFieldsInput
  clientMutationId: String
}

type UpdateTaskPayload {
  # This is the updated object.
  task: Task!
  clientMutationId: String
}

# The UpdateUserFieldsInput input type is used in operations that involve creation of objects in the User class.
input UpdateUserFieldsInput {
  ACL: ACLInput

  # This is the object username.
  username: String

  # This is the object password.
  password: String

  # This is the object email.
  email: String

  # This is the object emailVerified.
  emailVerified: Boolean

  # This is the object authData.
  authData: Object
}

input UpdateUserInput {
  # This is the object id. You can use either the global or the object id.
  id: ID!

  # These are the fields that will be used to update the object.
  fields: UpdateUserFieldsInput
  clientMutationId: String
}

type UpdateUserPayload {
  # This is the updated object.
  user: User!
  clientMutationId: String
}

# The `Upload` scalar type represents a file upload.
scalar Upload

# The User object type is used in operations that involve outputting objects of User class.
type User implements ParseObject & Node {
  # The ID of an object
  id: ID!

  # This is the object id.
  objectId: ID!

  # This is the date in which the object was created.
  createdAt: Date!

  # This is the date in which the object was las updated.
  updatedAt: Date!
  ACL: ACL!

  # This is the object username.
  username: String

  # This is the object email.
  email: String

  # This is the object emailVerified.
  emailVerified: Boolean

  # This is the object authData.
  authData: Object
}

# Allow to manage users in ACL. If read and write are null the users have read and write rights.
type UserACL {
  # ID of the targetted User.
  userId: ID!

  # Allow the user to read the current object.
  read: Boolean!

  # Allow the user to write on the current object.
  write: Boolean!
}

# Allow to manage users in ACL.
input UserACLInput {
  # ID of the targetted User.
  userId: ID!

  # Allow the user to read the current object.
  read: Boolean!

  # Allow the user to write on the current object.
  write: Boolean!
}

# A connection to a list of items.
type UserConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [UserEdge]

  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# An edge in a connection.
type UserEdge {
  # The item at the end of the edge
  node: User

  # A cursor for use in pagination
  cursor: String!
}

input UserLoginWithInput {
  ACL: ACLInput

  # This is the object email.
  email: String

  # This is the object emailVerified.
  emailVerified: Boolean
}

# The UserOrder input type is used when sorting objects of the User class.
enum UserOrder {
  objectId_ASC
  objectId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
  emailVerified_ASC
  emailVerified_DESC
  authData_ASC
  authData_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the User class.
input UserPointerInput {
  # Link an existing object from User class. You can use either the global or the object id.
  link: ID

  # Create and link an object from User class.
  createAndLink: CreateUserFieldsInput
}

# Allow to add, remove, createAndAdd objects of the User class into a relation field.
input UserRelationInput {
  # Add existing objects from the User class into the relation. You can use either the global or the object ids.
  add: [ID!]

  # Remove existing objects from the User class out of the relation. You can use either the global or the object ids.
  remove: [ID!]

  # Create and add objects of the User class into the relation.
  createAndAdd: [CreateUserFieldsInput!]
}

# The UserRelationWhereInput input type is used in operations that involve filtering objects of User class.
input UserRelationWhereInput {
  # Run a relational/pointer query where at least one child object can match.
  have: UserWhereInput

  # Run an inverted relational/pointer query where at least one child object can match.
  haveNot: UserWhereInput

  # Check if the relation/pointer contains objects.
  exists: Boolean
}

# The UserWhereInput input type is used in operations that involve filtering objects of User class.
input UserWhereInput {
  # This is the object objectId.
  objectId: IdWhereInput

  # This is the object createdAt.
  createdAt: DateWhereInput

  # This is the object updatedAt.
  updatedAt: DateWhereInput

  # This is the object ACL.
  ACL: ObjectWhereInput

  # This is the object username.
  username: StringWhereInput

  # This is the object password.
  password: StringWhereInput

  # This is the object email.
  email: StringWhereInput

  # This is the object emailVerified.
  emailVerified: BooleanWhereInput

  # This is the object authData.
  authData: ObjectWhereInput

  # This is the object id.
  id: IdWhereInput

  # This is the OR operator to compound constraints.
  OR: [UserWhereInput!]

  # This is the AND operator to compound constraints.
  AND: [UserWhereInput!]

  # This is the NOR operator to compound constraints.
  NOR: [UserWhereInput!]
}

# The Viewer object type is used in operations that involve outputting the current user data.
type Viewer {
  # The current user session token.
  sessionToken: String!

  # This is the current user.
  user: User!
}

# The WithinInput type is used to specify a within operation on a constraint.
input WithinInput {
  # This is the box to be specified.
  box: BoxInput!
}
